<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>

<#@ output extension=".cs"#>
<#

// This needs to be set to the .edmx file that you want to process.
string edmxFile = @"..\CurrentDesk.DAL\CurrentDesk.Container.edmx";
string namespaceSpecification = "CurrentDesk";
CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
MetadataTools ef = new MetadataTools(this);

#>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.Objects;


namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{ 
	internal interface IRepository<T> 
    {
		IUnitOfWork UnitOfWork { get; set; }
		IQueryable<T> All();
		IQueryable<T> Find(Func<T, bool> expression);
		void Add(T entity);
		void Delete(T entity);
		void Save();
    }
}<#


EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(edmxFile);
EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
{;
    
	fileManager.StartNewFile(entity.Name + "Repository.Generated.cs"); #>using System;
using System.Linq;
using System.Collections.Generic;
using CurrentDesk.DAL;
using CurrentDesk.Models;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and will be overwritten as soon as the template is executed

//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{   
	internal <#=code.SpaceAfter(code.AbstractOption(entity))#>partial class <#=code.Escape(entity)#>Repository
	{
		private IRepository<<#=code.Escape(entity)#>> _repository {get;set;}
		public IRepository<<#=code.Escape(entity)#>> Repository
		{
			get { return _repository; }
			set { _repository = value; }
		}
		
		public <#=code.Escape(entity)#>Repository(IRepository<<#=code.Escape(entity)#>> repository, IUnitOfWork unitOfWork)
    	{
    		Repository = repository;
			Repository.UnitOfWork = unitOfWork;
    	}
		
		public IQueryable<<#=code.Escape(entity)#>> All()
		{
			return Repository.All();
		}

		public void Add(<#=code.Escape(entity)#> entity)
		{
			Repository.Add(entity);
		}
		
		public void Delete(<#=code.Escape(entity)#> entity)
		{
			Repository.Delete(entity);
		}

		public void Save()
		{
			Repository.Save();
		}
	}
}<#	
	if(!DoesFileExist(entity.Name + "BO.cs"))
	{
		fileManager.StartNewFile(entity.Name + "BO.cs");
		#>using System;
using System.Linq;
using System.Collections.Generic;
using CurrentDesk.DAL;
using CurrentDesk.Models;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and this file should not get overridden 
//
//     Add your own data access methods.
// </auto-generated>
//------------------------------------------------------------------------------ 
	
namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{   
	<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#>class <#=code.Escape(entity)#>BO
	{
		// Add your own data access methods here.  If you wish to
		// expose your public method to a WCF service, marked them with
		// the attribute [NCPublish], and another T4 template will generate your service contract
		
	}
}<#
	}
	else
	{
		fileManager.StartNewFile(entity.Name + "BO.cs");
		this.Write(OutputFile(entity.Name + "BO.cs"));
	}
}

fileManager.StartNewFile("IUnitOfWork.cs");
#>using System.Data.Objects;


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and will be overwritten as soon as the template is executed

//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{
	internal interface IUnitOfWork
	{
		ObjectContext Context { get; set; }
		void Save();
		bool LazyLoadingEnabled { get; set; }
		bool ProxyCreationEnabled { get; set; }
		string ConnectionString { get; set; } 
	}
}<#	fileManager.StartNewFile("RepositoryIQueryableExtensions.cs");
#>using System.Data.Objects;
using System.Linq;
using CurrentDesk.DAL;
using CurrentDesk.Models;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and will be overwritten as soon as the template is executed

//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{
	internal static class RepositoryIQueryableExtensions
	{
		public static IQueryable<T> Include<T>
			(this IQueryable<T> source, string path)
		{
			var objectQuery = source as ObjectQuery<T>;
			if (objectQuery != null)
			{
				return objectQuery.Include(path);
			}
			return source;
		}
	}
}<# fileManager.StartNewFile("EFRepository.cs");
#>using System;
using System.Collections.Generic;
using System.Data.Objects;
using System.Linq;
using System.Text;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and will be overwritten as soon as the template is executed

//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{
	internal class EFRepository<T> : IRepository<T> where T : class
	{
		public IUnitOfWork UnitOfWork { get; set; }
		private IObjectSet<T> _objectset;
		private IObjectSet<T> ObjectSet
		{
			get
			{
				if (_objectset == null)
				{
					_objectset = UnitOfWork.Context.CreateObjectSet<T>();
				}
				return _objectset;
			}
		}

		public virtual IQueryable<T> All()
		{
			return ObjectSet.AsQueryable();
		}

		public IQueryable<T> Find(Func<T, bool> expression)
		{
			return ObjectSet.Where(expression).AsQueryable();
		}

		public void Add(T entity)
		{
			ObjectSet.AddObject(entity);
		}

		public void Delete(T entity)
		{
			ObjectSet.DeleteObject(entity);
		}

		public void Save()
		{
			UnitOfWork.Save(); 
		}
	}
}<#fileManager.StartNewFile("EFUnitOfWork.cs");
#>using System.Data.Objects;
using CurrentDesk.DAL;
using CurrentDesk.Models;
using System;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template at <#= DateTime.Now.ToString() #>
//	   and will be overwritten as soon as the template is executed

//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= code.VsNamespaceSuggestion()#>.<#=namespaceSpecification#>
{
	internal class EFUnitOfWork : IUnitOfWork,IDisposable
	{
		public ObjectContext Context { get; set; }

		public EFUnitOfWork()
		{
			Context = new <#=code.Escape(container)#>();
		}

		public void Save()
		{
			Context.SaveChanges();
		}
		
		public bool LazyLoadingEnabled
		{
			get { return Context.ContextOptions.LazyLoadingEnabled; }
			set { Context.ContextOptions.LazyLoadingEnabled = value;}
		}

		public bool ProxyCreationEnabled
		{
			get { return Context.ContextOptions.ProxyCreationEnabled; }
			set { Context.ContextOptions.ProxyCreationEnabled = value; }
		}
		
		public string ConnectionString
		{
			get { return Context.Connection.ConnectionString; }
			set { Context.Connection.ConnectionString = value; }
		}
		public void Dispose()
        {
            if (Context != null)
            {
                Context.Dispose();
                Context = null;
            }
        }
	}
}<#	fileManager.Process();
#>


<#+

bool DoesFileExist(string filename)
{			
	return File.Exists(Path.Combine(GetCurrentDirectory(),filename));	
}

string OutputFile(string filename)
{
	using(StreamReader sr = new StreamReader(Path.Combine(GetCurrentDirectory(),filename)))
	{
		string contents = sr.ReadToEnd();
		return contents;
	}
}

string GetCurrentDirectory()
{
	string executingDirectoryName = "";
	string stackTraceFileName = new StackTrace(true).GetFrame(0).GetFileName();
	if (String.IsNullOrEmpty(stackTraceFileName))
	{
		throw new ArgumentException("No value was specified for the 'directoryName' configuration parameter" +
			", and we could not figure out the file name from the stack trace (most likely because of running " +
			"the template with debug='False' specified in the <\u0023@ template \u0023> directive.");
	}
	else
	{		
		executingDirectoryName = Path.GetDirectoryName(stackTraceFileName);
	}	
	return executingDirectoryName;
}

string FindEDMXFileName()
{
	string edmxFile = "";
				
	string[] entityFrameworkFiles = Directory.GetFiles(GetCurrentDirectory(), "*.edmx");
	if(entityFrameworkFiles.Length > 0)
		edmxFile = entityFrameworkFiles[0];
	
	return edmxFile;
}
#>